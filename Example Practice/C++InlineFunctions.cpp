#include <iostream>
using std::cout;
using std::endl;
#define sum(i, j) i+j
inline int iSum(int i, int j) { return i + j; }
int add(int i, int j) { return i + j; }
// inline 함수
// 출처 및 참고: 2021학년도 2학기 인덕대학교 한성현 교수님 C++프로그래밍 강좌 6주차
// inline 함수는 함수 호출로 인한 지체를 줄이기 위해 대신 기계어로 변환된 함수 코드 블록({} 내부, 정의된 실행문)의 복사본을 삽입하는 부분을 의미한다.
// C의 #define문을 통한 매크로와 같이, 코드 블록이 짧은 함수는 inline 함수로 지정함으로 실행에서 시간 상의 지체(overhead)를 줄일 수 있다.
// 실행 파일에 함수를 호출하는 부분에서 파일 내에 그 함수의 코드 블록을 복사해 넣는 것으로 함수를 호출하는 부분을 생략한다.
// 기존 C의 #define문 매크로와 다른 점은 실제로 함수이기에 자료형 구분이 가능하며 연산자 우선 순위 문제 또한 상관 없다는 점이 장점이다.
// 대신 함수를 호출하는 부분에 통째로 넣는다는 점에서 호출 횟수가 많을 수록, 코드 블록의 길이가 길수록 파일 크기는 커지고 실행 속도까지 느려지는 의도하지 않는 상황이 발생할 수 있다.
// Visual C++에서 컴파일러의 재량 하에 따라 inline 함수로 선언되도 무시될 수 있고, 선언되지 않아도 짧아서 적절한 함수는 inline 함수로 취급하는 등 코드가 최적화되어 처리된다.

// inline 함수의 주의점과 처리 사항
// 1. inline 함수는 호출 전 정의 부분이 존재해야 한다. 기존의 함수는 main 함수 뒤에 적어도 호출 부분에서 인식해 알아서 처리했지만, 코드 블록을 통째로 복사해 넣는 경우에는 그럴 수 없기 때문이다.
// 2. inline 함수가 너무 긴 코드 블록을 지니고 있으면, 코드의 실행 속도는 조금 빨라져도 코드 파일의 크기가 너무 늘어나게 된다.
// 3. inline 함수가 너무 자주 호출되면(재사용되면) 그 횟수만큼 코드 블록이 더 들어가게 되므로, 실행 속도가 늦어져 의도치 않은 결과가 나올 수 있다.
// 4. 재귀 함수, switch문, for이나 while을 통한 반복문이 나오는 함수 또한 inline 함수로 선언되도 일반 함수로 취급한다.
// 5. 2와 3에 해당되어 코드 크기가 너무 커지면, 컴파일러가 알아서 판단해 inline 함수로 지정된 함수를 일반 함수로 취급한다.
// 6. 반대로 실행문이 한, 두 줄 정도의 짧은 함수는 inline 함수로 취급하며 그 이상은 컴파일러 재량 하에 판단해 처리하는 등 코드의 최적화에 inline 키워드가 이용된다.
// 7. 그리고 클래스 내부에서 선언 및 정의된 짧은 실행문을 지닌 멤버 함수도 inline 함수로 취급된다.

int main()
{
	cout << sum(10, 20) / 2 << endl; // define문으로 인한 매크로는 계산 과정을 거치는 것보다 그 부분을 그대로 넣는 식으로 계산한다.
	// sum(i,j)를 i+j라는 부분으로 변경해 코드를 보면 cout << 10 + 20 / 2가 나오게 된다. 이 경우 괄호를 쳐서 결과값을 보호하는 등으로 개선할 수 있다.
	cout << iSum(10, 20) / 2 << endl; // inline 함수는 컴파일러에서 실행 파일 내에 기계어로 코드 블록을 복사하기에, define문의 매크로보다 더 안정적이다.
	// int iSum(int i, int j)의 실행 부분을 파일 내에 복사해두었으므로, 함수가 진행된 뒤 출력이 실행되어 사실상 cout (10+20) / 2와 같이 실행된다.
	cout << add(10, 20) / 2 << endl;
	// int add(int i, int j)는 함수 호출 부분을 거쳐서 값을 출력하기 때문에 iSum보다는 느린 속도로 출력된다.
	return 0;
}
