#include <iostream>
using std::cout;
using std::endl;
void sub();

class Point {
	int x;
	int y;
	static int count; // 정적 멤버 변수의 경우, 클래스 내부에서 값을 초기화할 경우, 오류가 발생한다.
public:
	Point(int x, int y) : x(x), y(y) { count++; }
	~Point() { count--; }
	void print_count() { cout << count << '\n'; }
};
int Point::count = 0; // 이렇게 정적 멤버 변수는 멤버 함수를 밖에서 정의하듯이, 네임스페이스를 앞에 쓰고 변수의 값을 초기화해야 한다.
// 클래스 선언은 기억 장소를 할당하지 않는다. 실제로 기억 장소(메모리)가 할당되는 경우는 클래스가 main 함수 내에서 선언되어 객체가 될 때 메모리를 할당받는다.
// 그래서 기억 장소를 지정하기 위해 이렇게 미리 밖에 선언을 해놓는다.
// 정적 멤버 변수의 특징은 정적 변수와 같이 값을 저장하는데, 이게 이 클래스의 모든 객체에 해당된다.
// 동적 멤버 변수는 객체가 생성될 때마다 또 멤버 변수를 하나씩 객체에 할당하기 위해 생성하는데, 정적 멤버 변수는 제외된다.

// 1. 바인딩에 대하여 : 동적 바인딩 (Dynamic Binding) VS 정적 바인딩 (Static Binding)
// 바인딩: 변수나 함수에 대해서 메모리 할당 / 함수 호출 등 실제로 처리해야 하는 명령어들이 결정되는 시점
// 예시: 지역 변수 / static 변수 / 정적 함수 / 함수의 중복(Overriding)
// 정적 바인딩 (Static Binding) : 컴파일 시 결정되는 경우. static(정적) 변수나 중첩(Overloading)을 할 때 적용된다.
// 동적 바인딩 (Dynamic Binding) : run-time 시(실행할 때) 결정되는 경우. 지역 변수나 중복(Overriding)를 할 때 적용된다.
// 정적 바인딩은 컴파일 시 결정하므로, 일찍(Early) 결정하는 것이며, 동적 바인딩은 실행 때 코드를 살펴보고 결정하므로 늦게(Late) 결정하는 것이다.
// 동적 바인딩은 지역 변수와 같은 특징의 변수/함수를 만들고, 그들의 특징은 그들이 속한 블록 ( '{}' ) 안에서만 유효하다는 것이다.
// 정적 바인딩은 static 변수와 같은 특징의 변수/함수를 만들고, 그들의 특징은 프로그램이 끝날 때까지 자신의 값을 저장하고 기억한다는 것이다.
// 정적 바인딩과 동적 바인딩은 C++의 static(정적) 변수와 auto(혹은 그 어떤 지역 변수) 변수로도 볼 수 있지만, 대표적인 차이는 중첩(Overloading)과 중복(Overriding)에서 볼 수 있다.

// 2. 가상 함수와 함수의 중복(Overriding)
// 가상 함수: virtual 키워드가 앞에 붙여진 함수를 의미한다.
// 함수 중복(Overriding) : 상속된 클래스 사이에서 발생한다. 부모 클래스에 가상 함수가 있을 경우, 자식 클래스에서 가상 함수와 같은 이름의 함수를 정의한다면, 
// 재정의한 것으로 취급하고 이 클래스의 객체(인스턴스)에서는 재정의된 함수가 대신 호출된다. 부모 클래스의 함수에는 아무런 영향을 주지 않는다.
// 함수 중복의 개념은 전에 배웠던 중첩이 '확장'의 기능을 했다면, 중복은 '대체'의 기능을 했다고 볼 수 있다. 본래 함수가 같은 자료형에다가, 같은 형태의 매개 변수를 가지고 있을 경우 중복에서는 오류가 발생한다.
// 클래스 상속에서의 경우, 표면상으로는 중복이 되는 것 같이 보이지만, 자료형 / 매개 변수 / 이름이 모두 같은 함수를 구분할 리가 없고, 부모 클래스에서 상속 받은 함수가 먼저이므로 그것을 우선해서 실행할 뿐이다.
// 그런데 중복은 제한적이지만 그런 함수가 제대로 작동하도록 도와준다. 바로 함수의 우선 순위를 정해주는 것이다. virtual 키워드가 씌인 함수는 가상 함수로, 자식 클래스에서 같은 이름으로 다르게 정의하면
// 자식 클래스의 함수가 우선시 되어 호출되기 때문에, 같은 이름의 함수가 여러 객체 사이에서 여러 기능들을 가질 수 있게 해준다. 원하는 기능을 적재적소에 발휘하도록 할 수 있게 되는 것이다.
class A
{
public:
	int ss1(int i) { return(i * 2); }
	int dd1(int i) { return(ss1(i) * 2); }
	virtual int ss2(int i) { return (i * 2); } // 가상 함수는 보통 함수 앞에 virtual 키워드를 붙임으로서 만들 수 있다.
	virtual int dd2(int i) { return(ss2(i) * 2); }
};
class B : public A
{
public: // 부모클래스 A의 ss1, ss2 함수들이 마음에 들지 않아 자식클래스에서 재정의
 // 상속 받은 부분을 주석으로 처리
 // int ss1(int i) { return(i * 2); }
 // int dd1(int i) { return(ss1(i) * 2); }
 // virtual int ss2(int i) { return (i * 2); } // 상속된 가상 함수는 같은 이름의 함수가 자식 클래스에서 있을 경우 그 함수에게 우선 순위를 양보한다.
 // virtual int dd2(int i) { return(ss2(i) * 2); } // 상속된 가상 함수는 같은 이름의 함수가 자식 클래스에서 있을 경우 그 함수에게 우선 순위를 양보한다.
	int ss1(int i) { return(i * 3); } // 함수 중복을 사용하려 하지만 전혀 사용되지 않음
	int ss2(int i) { return(i * 3); } // 가상 함수 였던 ss2를 중복해서 덮어 씌움. B 클래스에서의 ss2 호출 시 A 클래스 ss2 대신 이 함수가 호출됨. A 클래스의 ss2까지 바꾸는 것은 아님.
	int dd1(int i) { return(ss1(i) * 3); } // 함수 중복을 사용하려 하지만 전혀 사용되지 않음
	int dd2(int i) { return(ss2(i) * 3); } // 가상 함수 였던 dd2를 중복해서 덮어 씌움. B 클래스에서의 dd2 호출 시 A 클래스 dd2 대신 이 함수가 호출됨. A 클래스의 dd2까지 바꾸는 것은 아님.
};


// 3. 순수 가상 함수와 추상 클래스,
// 순수 가상 함수: 함수 정의가 없는 가상 함수. 그러므로 함수 선언 상태에서 끝내기 위해서는 함수 이름()까지만 ㅆ,ㅡ고 = 0;과 같은 식으로 초기화해야 한다.
// 순수 가상 함수가 있는 클래스는 추상 클래스로 취급된다. 추상 클래스는 객체(인스턴스)화될 수 없다. 다만 상속은 가능하다.
// 순수 가상 함수를 상속 받은 자식 클래스는 무조건 가상 함수를 다시 재정의(같은 이름의 함수 선언 및 정의)해야 한다. 그렇게 하지 않으면 상속 받은 클래스도 추상 클래스가 되어 객체(인스턴스)화될 수 없다.
class Shape {// 추상 클래스(abstract class): 순수 가상 함수가 있는 클래스를 추상 클래스라 부르며, 이 클래스는 객체를 생성할 수 없다. 상속 용도로는 가능하다.
protected:
	double x = 1.1, y = 2.2;
public:
	// virtual double area() { return 0; } 	// 일반 가상 함수: 함수 선언과 정의가 제대로 되어 있는 함수가 virtual 키워드를 통해 가상 함수가 된 경우이다.
	virtual double area() = 0; // 순수 가상 함수: 함수 선언은 되었으나 정의가 되지 않은 가상 함수를 의미한다. = 0을 붙이는 이유는 {} 없이는 문장이 끝나지 않아 초기화하는 식으로 문장을 끝내야 하기 때문이다.
};

class Rectangle : public Shape { // 순수 가상 함수가 있는 추상 클래스를 상속 받을 경우, 무조건적으로 순수 가상 함수를 중복할 함수를 선언 및 정의(재정의)해야 한다.
private:
	double height, width;
public:
	Rectangle(double h, double w)
	{
		height = h; width = w;
	}
	double area() { return(width * height); } // 순수 가상 함수가 있는 추상 클래스를 상속 받고는 중복할 함수가 없는 채로 객체를 생성하면, 상속 받은 클래스도 추상 클래스로 취급 받아 오류가 발생한다.
};

class Triangle : public Shape {
private:
	double height, width;
public:
	Triangle(double h, double w)
	{
		height = h; width = w;
	}
	double area() { return(width * height / 2.0); }
};
// 4. virtual이 있고 없고의 차이점
// virtual이 없다는 것은 곧 가상 함수가 없고, 가상 함수가 없으면 함수의 중복도 인정되지 않는다.
// 그 경우 같은 이름의 함수는 중첩이 되는데, 부모 것이 우선시 되어 자식 클래스에 아무리 정의해도 기능하지 않는다.
// 그런데 부모 클래스의 함수에 virtual이 붙어 가상 함수가 되면 함수의 중복이 인정되어 같은 이름이라도 자식 클래스의 함수가 우선시 되기 때문에, 제대로 된 실행이 되게 된다.
class Dot {
public:
	virtual void draw() { cout << "Dot::draw()\n"; }
	void print() { cout << "Dot 클래스\n"; draw(); }
};

class Line : public Dot {
public:
	void draw() { cout << "Line::draw()\n"; }
};

int main()
{
	B bb;
	A* pA = new A;
	A* pB = new B; // 부모 클래스의 포인터는 자식 클래스를 가리킬 수 있음
	// Shape ss; // virtual double area()=0;
    // 윗줄 주석과 같이 순수 가상함수가 있으면 추상클래스이고
    // 추상클래스는 객체(인스턴스)를 만들 수 없음
	Shape* p; // 포인터 객체는 가능
	// 부모 클래스의 포인터는 그 클래스의 모든 자식 클래스의 객체에 접근할 수 있다.
	Rectangle nemo(10.0, 20.0);
	Triangle semo(10.0, 20.0);
	Line line;
	cout << "start\n";
	sub();
	sub();
	sub();
	cout << bb.dd1(2) << endl; // (2 * 3) * 3 // 가상 함수의 중복 적용
	cout << pA->dd1(2) << endl; // (2 * 2) * 2
	cout << pB->dd1(2) << endl; // (2 * 2) * 2
	cout << bb.dd2(2) << endl; // (2 * 3) * 3 // 가상 함수의 중복 적용
	cout << pA->dd2(2) << endl; // (2 * 2) * 2
	cout << pB->dd2(2) << endl; // (2 * 3) * 3 // 가상 함수의 중복 적용
	p = &nemo; // 자식의 주소를 부모 포인터에 대입
	cout << "네모 면적: " << p->area() << endl; //Rectangle::area()
	// 이런 식으로 부모 추상 클래스의 가상 함수가 호출될 경우, 
	// 부모 클래스의 포인터가 가리키는 객체의 클래스에 따라 맞춰서 그 클래스에 맞는 객체를 호출한다.
	// 이 경우 포인터가 가리키는 객체는 nemo, Rectangle 클래스이므로 Rectangle 클래스의 area를 호출한다.
	p = &semo;
	cout << "세모 면적: " << p->area() << endl; //Triangle::area()
	line.print();
	delete pA; delete pB;
	return 0;
}
// 실행 결과
//start
//3
//10 10 120
//3
//10 11 120
//3
//10 12 120
//18
//8
//8
//18
//8
//18
//네모 면적 : 200
//세모 면적 : 100
//Dot 클래스
//Line::draw()

void sub()
{
	Point a1(1, 2), a2(3, 4), a3(5, 6);
	a3.print_count(); // 3이 반복해서 나온다. a1부터 a3까지는 정적으로 적용되지만, 클래스 자체가 지역 변수이므로 블록을 벗어나는 경우 클래스 선언이 초기화되기 때문이다.
	int x = 10; // 동적 바인딩, run-time시
	auto x1 = 120; // auto는 C에서 기억 클래스 였지만, C++에서는 동적으로 가지고 있는 변수 값에 따라 자신의 자료형을 정하는 키워드가 되었다.
	// 즉 static auto 변수도 선언이 가능한 것이기에, auto가 붙어 있다고 무조건 적으로 동적 바인딩을 거치는 것은 아니다.
	static int y = 10; // 정적 바인딩, y의 초기값은 컴파일시 10으로 정해지며 실행시에 이 선언문은 실행하지 않음
	cout << x << ' ' << y << ' ' << x1 << '\n';
	x++;
	y++;
}
// 특징 정리
// A1. 바인딩은 변수/함수에 적용될 명령어들이 결정되는 시점이다. 메모리(기억 영역)의 할당 혹은 함수 호출 시 적용되는 규칙과 관련 있다.
// A2. 동적 바인딩은 지역 변수 혹은 함수 중복에 사용된다.
// A3. 정적 바인딩은 static 변수 혹은 함수 중첩에 사용된다.

// B1. 클래스 내 정적으로 선언하고 싶은 경우 자료형 앞에 static 키워드를 붙인다. 그 외에는 모두 동적으로 바인딩된다.
// B2. 멤버 변수는 정적일 경우 클래스 내 1개로 공유를 하며, 동적의 경우 객체에 하나씩 할당하기 위해 객체 생성 때마다 하나씩 생성된다.
// B3. 멤버 함수의 경우, 정적이든 동적이든 멤버 함수 하나를 가지고 공유해서 사용한다. 대신 정적으로 선언된 경우 클래스이름.함수이름(Point.print_count)와 같이 호출할 수 있다.

// C1. 함수의 중복은 상속된 클래스 사이에서 사용 가능한 방법으로, 부모 클래스가 가상 함수라면 자식 클래스에서 같은 이름의 함수가 선언되어도 자식 클래스의 함수가 우선되도록 할 수 있다.
// C2. 함수의 중복은 부모 클래스와 자식 클래스 내에서 같은 이름을 가진 함수가 위치에 따라 다른 기능을 발휘할 수 있게 하여 필요한 기능을 적재적소에 사용할 수 있게 해준다.
// C3. 가상 함수는 virtual 키워드를 보통 함수에 붙여서 만드며, 순수 가상 함수는 함수 정의가 되지 않은 함수를 가상 함수로 만들 경우 발생한다. ( 정의를 피하고 문장을 완성하기 위해 0으로 초기화하는 식으로 회피 )
// C4. 순수 가상 함수는 일종의 틀로서 작용한다. 상속 받은 클래스는 이 가상 함수의 틀을 재정의하여 채우지 않으면 제대로 된 작동을 하지 않는다. (객체(인스턴스)화 불가)
