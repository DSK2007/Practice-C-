#include <iostream>
using std::cout;
// C++의 동적 메모리 할당: new와 delete
// 출처 및 참고: 2021학년도 2학기 인덕대학교 한성현 교수님 C++프로그래밍 강좌 9주차
// 동적 메모리 할당(Dynamic Memory Allocation)은 실행 시간(Runtime) 동안 요청을 통해 메모리 공간을 할당하는 것을 의미한다. 후에 사용이 끝나면 반납을 통해 운영체제가 메모리를 다시 쓸 수 있다.
// int x = 2;와 같은 기존 변수 선언은 모두 메모리의 크기가 정해져 있어 필요하지 않은 공간까지도 메모리로 확보해 낭비할 수도 있다. 동적 메모리 할당은 이에 비해 메모리 크기의 할당이 필요한 만큼만 유연하게 할당해 유용하다.
// 동적 메모리 변수는 heap 영역에 저장되는 데, 이는 보통 지역 변수가 저장되는 stack 영역보다 크기에 대한 제약을 덜 받고, 다른 변수들이 stack 영역에 들어갈 때 메모리를 절약할 수 있기 때문에 이도 이점이다.
// 대신 포인터 변수에 대한 이해와 동적 메모리의 할당과 해제에 대한 정확한 통제가 필요하다. C에서도 malloc과 free라는 함수로 동적 메모리 할당을 구현할 수 있었다.
// 그리고 C++로 넘어오면서 malloc과 free의 역할을 할 수 있는 new와 delete 함수가 표준 라이브러리에 마련되어 그 전보다도 더 부담없이 동적 메모리 할당을 할 수 있다. 이에 대해 알아보자.
class Dog {
private:
	int age;
public:
	int getAge();
	void setAge(int a);
};
// 동적 메모리 할당의 장점
// 동적 메모리 할당은 앞서 나왔듯이 메모리의 크기가 자동적으로 알맞게 할당되기 때문에 기존에 프로그래머가 직접 정하는 것보다 메모리의 크기를 절약하고 안정적으로 운용할 수 있다는 점이 일단 가장 큰 이유이다.
// 이 큰 이유에서 다시 여러 이유를 파생해서 동적 메모리 할당이 왜 필요한 지, 왜 사용되는지에 대해 알아낼 수 있다.

// 1. 메모리 크기가 큰 개체(변수, 배열, 객체 등)를 부담없이 운용할 수 있어서
// 기존 지역 변수는 크기가 너무 크면 heap 영역과 그 부분을 나누거나 아예 할당을 못하는 오류가 발생한다.
// heap 영역은 stack 영역보다도 더 큰 크기의 변수를 받아도 부담이 적으며, 특히 동적 메모리로 할당된 개체는 그 메모리가 해제되면 다시 그 만큼 크기가 운영체제에 반환되기에 부담이 적다.

// 2. 메모리의 크기를 실행 시간(runtime)에 결정해야 해서 코드 작성 시 특정하기 어려울 때
// 이런 문제에 가까운 것이 바로 다른 변수를 배열의 크기로 가지는 배열이다. 기존의 배열은 상수식이 아닌 다른 변수를 배열의 크기로 받을 수 없다.
// 그런데 동적 메모리 배열은 사용자가 입력한 변수의 값을 배열의 크기로 할 수 있을 정도로 사용자에 입력 값에 대해 더 유연하게 대응할 수 있다.
// 동적 메모리 배열이 아닌 경우라도, 크기가 너무 부족해 값을 처리하지 못하거나, 크기가 너무 커서 메모리가 낭비되는 경우가 자동으로 차단된다는 점에서도 유용하다.

// 3. 값을 기억하는 지역 변수가 필요할 때
// 이는 정적 메모리 할당인 static 변수로도 할 수 있지만, 정적 메모리 할당은 메모리 크기가 고정되고 너무 큰 크기는 할당할 수 없다는 점에서 동적 할당이 더 유리하다.

// 동적 메모리 할당의 단점
// 1. 동적 메모리 할당이 이루어지는 heap 영역은 기존 지역 변수가 저장되는 stack 영역보다 처리 속도가 느리다.
// 2. 동적으로 할당된 메모리는 기억 공간에 이름(식별자)가 없기에 주소를 사용한다. 그렇기 때문에 포인터 변수 선언 등 포인터에 대한 이해가 필요하다.

	// 예제 1: new와 delete에 대한 소개: 동적 메모리 변수
	// int* pi = new int; // C의 malloc같이 포인터 변수에 복사 초기화하는 방식으로 메모리를 할당한다.
	// new는 메모리를 동적으로 할당하고, 할당된 메모리에 대한 주소를 반환하는 연산자이다. new int는 int 형태의 포인터(변수의 시작 주소)를 자동적으로 반환한다.
	// 포인터 변수 pi에 이런 동적으로 할당된 메모리의 주소값을 저장하면, 그 할당받은 메모리의 포인터를 역참조하여 사용할 수 있다.
	// int x;

	// if (!pi) {
		// cout << "메모리 할당이 되지 않았습니다."; // malloc 함수와 같이 new도 요구한 만큼 메모리가 충분하지 않으면 null 포인터를 반환한다.
		// 그 경우 포인터 변수는 제대로 된 반환값을 받지 못하므로, 0으로 남아 변수가 비어있게 된다. !pi는 이러한 점을 캐치해 변수의 값이 0인 경우(메모리가 할당되지 못한 경우)를 대비한다.
		// return 1; // 비정상 종료 시 리턴값 // main 함수의 return문은 프로그램의 종료를 알리는 동시에(뒤에 쓰인 문을 무시하고 값을 반환하고 넘어가게 됨) 그 반환값으로 프로그램이 정상 동작했는지를 구분할 수 있다.
	// }
	// *pi = 100;
	// x = 10;
	// cout << "동적 메모리=" << *pi << ", x=" << x;

	// delete pi; // delete 함수는 지정한 메모리를 해제한다. 메모리가 해제되어도 이 함수는 다시 동적으로 다른 메모리가 할당되거나 다른 변수의 주소값을 받는 등 정상적으로 동작할 수 있다.
	// 단, delete가 종료 전에라도 나와야 하는 이유는, 정적 메모리 할당과 달리 프로그램 종료 시 자동적인 메모리 해제가 이루어지지 않기 때문에, 메모리 누수가 일어날 수 있기 때문이다.
	// 그러므로 delete를 통해 동적 메모리 변수는 명시적으로 그 메모리 해제가 알려져야 한다.

	// new와 delete는 C의 malloc과 free에 비해 장점이 있다.
	// 1. new는 malloc과 달리 메모리를 자동적으로 할당해 더 편하고, 코드의 길이 또한 더 적어진다. [ int *pi = new int; vs. int *pi = (int*)malloc(sizeof(int)); ]
	// 1-1. 이유: new 연산자는 지정한 자료형의 포인터(변수의 시작 주소)를 자동적으로 반환한다. + 지정된 형의 크기 만큼 자동으로 메모리 크기를 할당해 sizeof와 같은 연산자가 필요 없다.
	// 2. new와 delete는 중첩이 가능하다.
	// 3. 동적으로 할당된 객체의 초기화를 할 수 있다. (생성자를 자동으로 호출한다.)
	// 4. malloc.h나 stdlib.h를 포함할 필요 없이 기존 라이브러리 iostream에 포함되어 있다.
	// return 0; // 정상 종료 시 리턴값

	// 예제 2: 변수를 배열의 크기로 가지는 동적 배열
	//int i, n;
	//int* num;
	//cout << "몇 개의 숫자를 입력하시겠습니까==";
	//cin >> i;

	//// 동적 변수와 달리 동적 배열은 new와 delete에 []를 붙여서 사용한다.
	//// new[]는 자료형 뒤에 [배열의 크기]를, delete는 키워드 뒤 바로 []를 붙여 사용한다.
	//// new int와 new int[2]가 다르듯 delete와 delete[]도 다르다.
	//// 그러므로 동적 배열의 메모리를 해제하기 위해서는 delete[]를 사용하는 것을 잊지말자.

	//num = new int[i]; // new[]를 통해 변수를 배열의 크기로 하는 배열을 선언할 수 있다.
	//if (num == NULL) { cout << "메모리 할당이 되지 않았습니다."; return 1; } // new
	//for (n = 0; n < i; n++)
	//{
	//	cout << "숫자를 입력하십시오 : ";
	//	cin >> num[n];
	//}
	//cout << "당신이 입력한 숫자는: ";
	//for (n = 0; n < i; n++)
	//{
	//	cout << num[n] << ", ";
	//}
	//delete[] num; // delete[]를 통해 동적 배열의 메모리를 해제할 수 있다.
	//return 0;

int main()
{
	// 예제 3: 객체 배열의 동적 할당
	Dog* dp;
	dp = new Dog[10]; // 위와 이 줄까지를 Dog *dp = new Dog[10]; 로 줄여 쓸 수 있다.
	if (!dp) { cout << "메모리 할당 불가!"; return 1; }
	for (int i = 0; i < 10; i++)
	{
		dp[i].setAge(i + 1); // 나이는 0살이 될 수 없으므로 1부터 시작한다.
	}
	for (int i = 0; i < 10; i++)
	{
		cout << (i + 1) << "번째 객체의 나이는 " << dp[i].getAge() << "입니다." << "\n";
		// 배열의 방은 0부터 시작하지만, 0은 사실 배열의 1번째 방이므로 1번째 객체라 칭해도 상관 없다.
	}
	delete[] dp;
	return 0;
}
// 실행 결과
//1번째 객체의 나이는 1입니다.
//2번째 객체의 나이는 2입니다.
//3번째 객체의 나이는 3입니다.
//4번째 객체의 나이는 4입니다.
//5번째 객체의 나이는 5입니다.
//6번째 객체의 나이는 6입니다.
//7번째 객체의 나이는 7입니다.
//8번째 객체의 나이는 8입니다.
//9번째 객체의 나이는 9입니다.
//10번째 객체의 나이는 10입니다.

int Dog::getAge() { return age; }
void Dog::setAge(int a) { age = a; }
