#include <iostream>
using std::cout;
using std::endl;

// 여러 개의 기본 클래스 상속 / 상속 심화 편
// 출처 및 참고: 2021학년도 2학기 인덕대학교 한성현 교수님 C++프로그래밍 강좌 13주차(12주차 포함)
// 이번 정리에서는 클래스에 대한 것과 상속에 대한 것을 어느 정도 정리한다.

// 자식 클래스, 파생 클래스 = 상속 받은 클래스 / 부모 클래스, 기본 클래스 = 상속한 클래스
// AA 클래스는 AB의 부모 클래스이다. AB는 AA의 자식 클래스이다. 이와 같은 관계를 영문으로 표기한 관계를 is_a 관계라고 한다.
// is_a 관계는 부모 클래스(기본 클래스)를 superclass, 자식 클래스(파생 클래스)를 subclass로 변경해 문장을 구성한다.
// AA is superclass of AB. AB is subclass of AA. 와 같이 문장을 만들어 낼 수 있다.
// 이가 중요한 이유는 클래스 다이어그램에서 상속을 표현할 시, 상속받은 클래스가 상속한 클래스에 화살표를 뻗는 형식으로 ( AB -> AA ) 표시되기 때문이다.

class AA { // 클래스 선언. 변수와 같이 class를 앞에 쓰고 그 클래스의 이름을 적어 선언한다.
	// 클래스에는 private, protected, public이라는 접근 제어 속성이 있으며, 이는 보안성이 높은 순대로 나열한 것이다.
	// 상속 시 상속할 클래스 앞에 접근 제어 속성이 붙으며, 이는 클래스의 멤버가 상속된 후 멤버들의 속성이 만약에 이 속성보다 보안성이 낮은 경우, 이 속성으로 속성을 변경시킨다.
private: // private 속성: main 함수에서 호출/참조 불가 / 상속 불가(자식 클래스 내부에서도 참조 불가. 부모 클래스의 멤버 함수로만 접근 가능) / 주로 상속하지 않을 멤버 변수가 위치함
	int a;
	// protected 속성: main 함수에서 호출/참조 불가 / 상속 가능(클래스 내부에서 참조 및 호출 가능) / 상속 시 정보를 드러나지 않게(직접 참조/호출이 불가)하고 싶을 때 사용함.
public: // public 속성: main 함수에서 호출/참조 가능 / 상속 가능 / 거의 모든 멤버 함수, 그리고 생성자와 소멸자가 여기 위치함
	AA(int i) : a(i) { cout << "AA 객체 생성" << endl; }
	int getA() { return a; }
	~AA() { cout << "AA 객체 소멸" << endl; }
};

class BB {
	// 클래스에서 속성이 생략된 부분이 있다면, 그 멤버는 private 속성이다.
	int b;
public:
	BB(int i) : b(i) { cout << "BB 객체 생성" << endl; }
	int getB() { return b; }
	~BB() { cout << "BB 객체 소멸" << endl; }
};

// 여러 개의 기본 클래스 상속
// 여러 기본 클래스들이 계층처럼 쌓여 하나의 자식 클래스가 여러 기능을 갖게 하는 계층적 다중 상속이 있지만,
// 여러 개의 기본 클래스를 동시에 상속해주는 것도 여러 기능을 갖게 해주는 방법 중 하나이다.
// 기본 클래스를 두 개 이상 상속할 경우, 쉼표(',')로 구분해 차례를 구분한다.
// 가장 콜론(':')에 가까운 부모 클래스가 가장 먼저 상속된 것으로 친다. 그 뒤 순서는 차례대로 이다.

// [여러 개의 클래스를 상속할 시 생성자와 소멸자의 우선 순위]
// 상속은 이렇게 다른 멤버 함수처럼 public 속성에 있는 생성자와 소멸자 또한 상속한다.
// 생성자의 우선 순위는 먼저, 부모 클래스부터 먼저 생성자를 호출한다. 그리고 가장 먼저 상속된 클래스, 콜론(':')과 가장 가까운, 왼쪽으로부터 오른쪽으로 순위가 정해지며, 가장 마지막은 자식 클래스이다.
// 소멸자는 생성자 우선 순위와 반대의 순서를 지닌다. 자식 클래스가 가장 먼저 소멸자를 호출하며, 상속된 클래스 중에서는 오른쪽에서부터 왼쪽으로 순위가 정해진다.
// 정리하자면, 생성자는 자식 클래스가 가장 나중, 나머지는 왼쪽->오른쪽 / 소멸자는 생성자 순서의 반대
class AB : public AA, public BB { // 클래스 AA, 클래스 BB의 변수 및 기능 상속
	int ab;
public:
	AB(int i, int j, int k) : AA(i), BB(j), ab(k) { cout << "AB 객체 생성" << endl; }
	int getAB() { return ab; }
	void show() { cout << getA() << ' ' << getB() << ' ' << ab << endl; }
	~AB() { cout << "AB 객체 소멸" << endl; }
};

int main()
{
	// AA 객체 생성 
	// BB 객체 생성 
	// AB 객체 생성
	AB ab(4, 5, 6);
	cout << ab.getA() << endl; // 4
	cout << ab.getB() << endl; // 5
	cout << ab.getAB() << endl; // 6
	ab.show(); // 4 5 6
	// AB 객체 소멸
	// BB 객체 소멸
	// AA 객체 소멸
	return 0;
}
