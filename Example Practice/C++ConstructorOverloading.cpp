#include <iostream>
using std::cout;
using std::endl;
// 생성자 중첩 (Constructor Overloading)
// 출처 및 참고: 2021학년도 2학기 인덕대학교 한성현 교수님 C++프로그래밍 강좌 10주차
// 생성자 중첩은 함수 중첩 중 가장 많이 사용되는 중첩이다. 클래스 내부에서 멤버 함수 또한 중첩이 가능하나, 소멸자는 매개 변수를 가지지 못하므로 중첩이 불가능하다.
// 생성자도 멤버 함수나 다른 사용자 정의 함수와 같이 매개 변수를 가지기 때문에 자료형이나 변수 개수에 따라 여러 개의 생성자가 중첩이 가능하다.
// 생성자 중첩을 하는 원인은 클래스의 초기값을 다양하게 설정할 선택지를 넓히기 위해서이다.
// 애플, 안드로이드 등이 만든 클래스를 보아도 많은 생성자가 중첩되어 있다. 더 다양한 자료 범위의 인스턴스(메모리에서 사용 중인 객체)를 생성하기 위해서이다.

class Dog {
private:
	int age;
public:
	Dog() { age = 1; } // 매개 변수가 없는 경우의 기본 생성자
	Dog(int a) { age = a; } // 매개 변수가 있는 경우의 생성자 (갯수나 자료형에 따라 구분 가능)
	Dog(char a) { int b = a - '0'; age = b; } // 문자형 매개 변수를 받아 숫자로 바꿔서 나이에 저장하는 생성자
	~Dog();
	int getAge();
	void setAge(int a);
};

int main()
{
	// 생성자 중첩 또한 생성자 함수를 중첩하는 것이기 때문에 함수 중첩과 동일하다.
	// 예를 들자면 Dog(int i, string s)와 Dog(int b, string t)는 중첩될 수 없어 오류가 발생한다. 가지고 있는 자료형과 그 갯수가 int 자료형 변수 1개, string 자료형 변수 1개로 동일하기 때문이다.
	Dog happy(8), meri, doge('3'); // happy(5)는 매개 변수가 있으므로 나이가 전달 받은 수 5, meri는 매개 변수가 없어 기본 생성자 정의 대로 나이가 1.
	Dog puppy[5], husky[5]{ 1,2,3,4,5 }; // 객체 배열의 생성자는 초기화를 통해 매개 변수를 각 요소마다 받으며, 요소마다 받는 매개 변수에 따라 생성자가 호출된다. 없을 경우에도 모든 요소에 기본 생성자가 호출된다.
	cout << happy.getAge() << " " << meri.getAge() << " " << doge.getAge() << endl; // 8 1 3
	for (int i = 0; i < 5; i++) {
		cout << puppy[i].getAge() << " " << husky[i].getAge() << endl; // 1 1, 1 2, 1 3, 1 4, 1 5
	}
	return 0;
}
// 실행 결과
//8 1 3
//1 1
//1 2
//1 3
//1 4
//1 5
//소멸
//소멸
//소멸
//소멸
//소멸
//소멸
//소멸
//소멸
//소멸
//소멸
//소멸
//소멸
//소멸

Dog::~Dog() { cout << "소멸" << endl; }
int Dog::getAge() { return age; }
void Dog::setAge(int a) { age = a; }
