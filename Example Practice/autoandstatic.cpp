#include <iostream>
using std::cout;
using std::endl;
void sub(void);
// 출처 및 참고: 2021학년도 2학기 인덕대학교 한성현 교수님 C++프로그래밍 강좌 4주차
// 기억 클래스 auto와 static
// 기억 클래스란, 변수에 부여되는 것으로 정해진 종류에 따라 변수의 값이 어떤 종류의 메모리에 저장될 지를 정하는 지정자이다.
// 메모리 영역들 중 우리가 주로 사용하는 영역은 스택 영역, 데이터 영역, CPU 레지스터 영역이 존재한다.
// auto는 스택 영역, static은 데이터 영역에 값이 저장되게 한다.
// auto는 기본적으로 기억 클래스를 선언하지 않는 변수들에게 기본으로 주어지는 기억 클래스로, 자료형 앞에 쓰지 않아도 그대로 사용된다.
// 소스 내에는 지역이 존재하고, 이는 소스 내에 int main(void){}와 같이 {}안을 의미한다. 만약에 선언된 변수가 {} 안에 있지 않으면, 정적 변수로 소스 어디서든 사용할 수 있다.
// auto는 그 변수가 선언된 지역({})에서만 활용되고, 그 밖에서는 사용할 수 없다.
// static은 auto와 달리 선언된 지역 밖에서도 사용할 수 있는데, 위에서 말한 {} 안에 있지 않는 곳에서 선언된 변수와 같이 소스 어디서든 사용할 수 있다.
// 정적 변수는 모든 변화를 기록하므로 함수 내에서 호출되어 변화되었을 때도 보통 auto 변수와 달리 그 변화를 유지한다.
// 그러나 C++에서는 자료형 앞에 auto를 쓸 수 없게 되었는데, 이제 auto는 변수 선언에서 일종의 자료형 개념으로 취급되기 때문이다.
// sub 함수 설명에서 후술한다.

int main(void)
{
	sub();
	sub();
	sub();
	return 0;
}

void sub(void)
{
	int x = 10; //  C++에서 auto는 선언 지정자로, 주어진 값에 따라 그 변수의 형식이 지정되는 형식을 의미한다.
	// 기존의 기억 클래스의 역할을 잃어 달라졌으므로 auto int x = 10;과 같이 동시에 사용할 수 없다.
	// 그러나 기억 클래스가 없는, 어떠한 지역({}) 내의 변수는 무조건 동적 변수, 기억 클래스 auto를 가진다는 점에서 C++ 내에서 사용되지 않는 것은 아니다.
	static int y = 10; // static은 기존의 역할을 유지하며 자료형 앞에 쓰이는 것으로 사용할 수 있다.
	cout << "x=" << x << ", " << "y=" << y << endl;
	x++; // 동적 변수 x는 기억 클래스 auto를 가져, 이 지역(sub 함수) 내에서만 사용되고 밖에서는 다시 값이 초기화된다.
	y++; // 정적 변수 y는 함수 호출에서 생긴 변화를 프로그램 실행 동안 기록해 저장하기 때문에, 반복적으로 호출하면 y의 값 또한 점차 커진다.
}
// 실행 결과 
//x = 10, y = 10
//x = 10, y = 11
//x = 10, y = 12
