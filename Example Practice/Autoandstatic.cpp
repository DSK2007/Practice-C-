#include <iostream>
using std::cout;
using std::endl;
void sub(void);
// 출처 및 참고: 2021학년도 2학기 인덕대학교 한성현 교수님 C++프로그래밍 강좌 4주차
// 기억 클래스 auto와 static
// 기억 클래스란, 변수에 부여되는 것으로 정해진 종류에 따라 변수의 값이 어떤 종류의 메모리에 저장될 지를 정하는 지정자이다.
// 메모리 영역들 중 우리가 주로 사용하는 영역은 스택 영역, 데이터 영역, CPU 레지스터 영역이 존재한다.
// auto는 스택 영역, static은 데이터 영역에 값이 저장되게 한다.
// auto는 기본적으로 기억 클래스를 선언하지 않는 변수들에게 기본으로 주어지는 기억 클래스로, 자료형 앞에 쓰지 않아도 그대로 사용된다.
// auto 변수는 동적 변수라고도 하는데, 이는 그 함수의 지역이 프로그램 내에서 사용 중일 때만, 활성화되어 사용되기 때문이다. 
// 물론 변화가 일어나지 않는 한 지역의 변수 값은 초기화되지 않으나, 사용자 정의 함수 호출과 같이 그 지역 내로 반복해 진입하는 경우 정적 변수가 아닌 한 변수 선언이 우선시 되어 초기화 된다.
// 이는 sub 함수의 int x와 같은 곳에서 이 현상을 관찰할 수 있다. 함수 끝에 x는 x++로 10에서 11이 되었는데도, 다시 호출하면 중간의 출력은 그대로 10을 출력한다. 값이 초기화되었기 때문이다.
// 소스 내에는 지역이 존재하고, 이는 소스 내에 int main(void){}와 같이 {}안을 의미한다. 만약에 선언된 변수가 {} 안에 있지 않으면, 전역 변수로 소스 어디서든 사용할 수 있다.
// auto는 그 변수가 선언된 지역({})에서만 활용되고, 그 밖에서는 사용할 수 없다.
// static 변수는 기억 클래스가 없는, 그리고 지역 밖에서 선언된 전역 변수는 자동적으로 이 기억 클래스로 취급되며, 혹은 따로 지역 내에서 static을 붙임으로서 선언할 수 있다.
// static 변수은 정적 변수라고도 하는데, 이는 auto 변수와 달리 데이터 영역에 값을 저장하는 것으로 지역 사이를 오고 갈 때(함수 호출 등) 변수의 값이 변경될 때 초기화되지 않는다는 점이 특징이다.
// 정적 변수는 모든 변화를 기록하므로 함수 내에서 호출되어 변화되었을 때도 보통 auto 변수와 달리 그 변화를 유지한다.
// 이는 sub 함수의 static int y와 같은 곳에서 이 현상을 관찰할 수 있는데, int x와 달리 y는 호출될 때마다 1씩 증가하는 것을 저장해 반복 호출할 경우 출력되는 y의 값도 증가한다는 것으로 알 수 있다.
// 정리하자면, main 함수나 사용자 정의 함수 등 지역({}, 중괄호 내부)에서 선언된 변수는 자동적으로 동적(auto) 변수, 지역 바깥에서 선언된 전역 변수는 정적(static) 변수로 취급된다.
// 또한 C에서는 전역 변수 선언에는 auto 기억 클래스를 사용할 수 없다. C++에서는 아예 auto 기억 클래스를 자료형 앞에 사용할 수 없게 되었다.
// 앞서 서술한 것과 같이 C++에서는 자료형 앞에 auto를 쓸 수 없게 되었는데, 이제 auto는 변수 선언에서 일종의 자료형 개념으로 취급되기 때문이다.
// sub 함수 설명에서 후술한다.

int main(void)
{
	sub();
	sub();
	sub();
	return 0;
}

void sub(void)
{
	int x = 10; //  C++에서 auto는 선언 지정자로, 주어진 값에 따라 그 변수의 형식이 지정되는 형식을 의미한다.
	// 기존의 기억 클래스의 역할을 잃어 달라졌으므로 auto int x = 10;과 같이 동시에 사용할 수 없다.
	// auto 자료형을 지닌 변수는 컴파일러가 초기화식에 따라 자동적으로 그 변수의 형식을 추론해 지정한다.
	// 코딩에서 자료형을 따로 지정하지 않아도 되기에, 자료형 변환이 이루어지지 않는 한, auto 자료형을 사용하는 것은 시간을 아끼는 좋은 방법일 수도 있다.
	// 그러나 자료형 타입을 기억해 두기 위해서는 그 자료형을 직접 타이핑해보고 어떤 초기화 식을 써야 이 자료형 타입을 가진 변수에 맞는 지에 대해 알 수 있다.
	// 그러나 기억 클래스가 없는, 어떠한 지역({}) 내의 변수는 무조건 동적 변수, 기억 클래스 auto를 가진다는 점에서 C++ 내에서 사용되지 않는 것은 아니다.
	static int y = 10; // static은 기존의 역할을 유지하며 자료형 앞에 쓰이는 것으로 사용할 수 있다.
	cout << "x=" << x << ", " << "y=" << y << endl;
	x++; // 동적 변수 x는 기억 클래스 auto를 가져, 이 지역(sub 함수) 내에서만 사용되고 밖에서는 다시 값이 초기화된다.
	y++; // 정적 변수 y는 함수 호출에서 생긴 변화를 프로그램 실행 동안 기록해 저장하기 때문에, 반복적으로 호출하면 y의 값 또한 점차 커진다.
}
// 실행 결과 
//x = 10, y = 10
//x = 10, y = 11
//x = 10, y = 12
