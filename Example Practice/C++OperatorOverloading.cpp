#include <iostream>
using std::cout;
using std::endl;
using std::string;
// 연산자 중첩(연산자 오버로딩)
// 출처 및 참고: 2021학년도 2학기 인덕대학교 한성현 교수님 C++프로그래밍 강좌 11주차
// 연산자 중첩는 기존 연산자의 의미를 사용자 정의대로 재 정의한 것을 가지고 의미를 확장해 다형성(한 이름으로 여러 기능)을 구현하는 방법 중 하나이다.
// 연산자 중첩을 쉽게 생각하자면, 함수인데, 특별한 함수 이름을 가지고 있다고 보면 된다.
// 그렇기에 연산자 중첩은 클래스의 멤버 함수처럼 선언 및 정의가 필요하고, 정의는 클래스 바깥에서도 이루어질 수 있다.
// 특별한 함수 이름이란, operator 키워드와 연산자를 합친 부분을 말하는 것이다.
// + 연산자를 중첩하면 'operator +'(2항 연산), 혹은 'operator ++'(증감)과 같은 형식의 이름이다.

// 사전 지식
// 연산자 중첩에 대해 배우기 전, C에서 배웠던 연산자에 대해 어느 정도 다시 복습할 필요가 있다.
// 연산자(operator)는 변수, 상수에 무엇을 행하는 기호/단어, 피연산자(operand)는 그 연산자가 연산을 하는 대상이다.
// 그리고 피연산자의 수에 따라 항으로 갈리게 된다. 2항이 기본적이다. 예시: [ 단항: a++, ++b; / 2항: a+b; ]
// 그리고 단항에 대해서는 기본적으로 +와 -(증감)가 후치와 전치라는 개념을 가진다.
// 전치(선처리): ++a; 연산부터 하고 대입이 된다. 즉 연산으로 변화된 값이 대입된다. 후치(후처리): a++; 대입이 먼저 일어나고 연산이 된다.
// 연산자의 우선순위 또한 고려해야 한다. 우선 순위는 중첩해도 바뀔 수 없다. 1. 괄호() 안, -> 2. *, / -> 3. +, -
// 대입 연산자(=, += 등)은 오른쪽->왼쪽으로 실행, 우선순위가 같으면 왼쪽->오른쪽으로 연산을 진행한다.

// 연산자 중첩의 필요성
// 문자열 i와 j가 i+j를 한다면 C에서는 그를 적용할 수 없다. 대신 strcat 함수를 사용해 구현한다.
// C의 char와 같이 클래스로 생성된 객체 또한 이러한 문제를 겪는다. +, * 등 연산자가 제대로 작동하지 않는다.
// 그래서 멤버 함수를 만들어 멤버 변수들 끼리 따로 계산한 값을 리턴해주거나 멤버 변수 둘의 값을 다시 리턴해 연산에 사용해야 한다.
// 이러한 과정을 건너뛰고 간결하게 만들기 위해 연산자를 중첩하면, 객체 i와 j가 i+j, i*j 등 연산이 정상적으로 적용되게 할 수 있다.
// 연산자 중첩은 함수 정의와 같이 선언과 정의가 되지만, 호출 방식이 더 간단하고 코드가 보기에도 간단해진다.

class Point {
	int x;
	int y;
public:
	Point() { x = 0, y = 0; }
	Point(int i, int j) { x = i; y = j; }
	int getX() { return x; }
	int getY() { return y; }
	void Print() { cout << "(" << x << ", " << y << ")" << endl; }

	// 연산자 중첩은 함수 정의와 같은 형식을 사용한다. 대신 operator 키워드와 연산자 이름이 함수 이름으로 들어간다는 점이 차이다.
	// 그리고 앞서 보았듯이 + 연산자는 ++. +와 같이 항에 따라 모양이 다르고 전치, 후치라는 개념도 있다.
	// 이런 식으로 + 연산자는 하나일지라도 의미가 갈리면, 기능 또한 달라진다.
	// 그러므로 연산자 중첩 또한 이를 따라간다. 전치 단항 ++, 후치 단항 ++, 2항 + 모두 사용할 때 각각의 중첩이 필요하다.

	// 연산자 중첩 - 선언 및 정의
	// 이 모든 예시는 클래스 Point를 예시로 두고 작성되었다.
	// 전치 (증감 연산자) : 리턴형(클래스이름) operator 연산자() -> Point operator ++() -> ++p1;
	// 후치 (증감 연산자) : 리턴형(클래스이름) operator 연산자(int) -> Point operator --(int) -> p1--;
	// 2항: 리턴형(클래스이름) operator 연산자(매개 변수) -> Point operator +(int x) -> p1+2;
	// 형 변환 함수의 경우: operator 바뀌게될자료형이름() {return 변환값} -> operator int {return x*y:}

	// 연산자 중첩은 연산자의 의미를 확대, 재정의한다.
	// 연산자 중첩은 함수 정의와 같기 때문에 사용자가 정의하면 그 의미가 변질될 수도 있다.
	// 그걸 대비하기 위해 +를 굳이 -의 기능으로 재정의해서 쓰는 것보다,
	// 클래스의 무엇을 '더한다'는 기능만은 유지시켜 이름 또한 +, 혹은 ++를 그대로 쓸 수 있도록 하자.
	// 예컨대 멤버 변수 x,y를 가진 Point 클래스 객체 사이의 + 연산은 곧 멤버 변수 x,y끼리 더하게 만드는 것이다.
	// 또한 객체 자신에 리턴값을 적용하기 위해 this 포인터를 이용한 return *this(객체 자기 자신을 반환)을 사용하자.

	// + 연산자: 두 수를 더하는 연산자
	Point operator ++(); // 전치 단항 ++ -> Point 클래스형 객체에서 멤버 변수 x,y,를 각각 증가 (선처리)
	Point operator ++(int); // 후치 단항 ++ -> Point 클래스형 객체에서 멤버 변수 x,y를 각각 증가 (후처리)
	Point operator +(Point ob); // 2항 +-> Point 클래스형 객체에서는 멤버 변수 x,y를 각각 더하는 연산자로 재정의.
	Point operator -(Point ob); // 2항 --> Point 클래스형 객체에서는 멤버 변수 x,y를 각각 빼는 연산자로 재정의.
	Point operator *(Point ob); // 2항 * -> *의 '곱한다' 기능과 이름 유지, 멤버 변수 x와 y를 곱하는 연산자로 재정의
	char operator ==(Point ob); // 2항 == -> 앞과 달리 결과를 T 또는 F, 글자로 반환하기에 char형. ==의 두 값을 비교한다는 점에서 이름과 기능 유지.
	string operator !=(Point ob); // 2항 != -> ==와 반대로 둘 다 같지 않으면 무조건 T, 둘다 같으면 F를 반환.
	operator int() { return x * y; } // 형 변환 함수: 리턴형을 가지지 않는, operator 키워드 + 자료형으로 구성되는 함수.

	// 형 변환 함수는 한 객체의 자료형을 다른 객체의 자료형(또는 int와 같은 현존하는 자료형)으로 변환 시 사용된다.
	// 형 변환 함수는 매개 변수를 갖지 않으며, 형 변환을 수행하는 클래스의 멤버 함수이어야 한다.
};

int main()
{
	Point p1(2, 3), p2(3, 5), p3, p4, p5(3, 4);
	int i;
	++p1; // 연산자 중첩이 적용될 경우, 이렇게 다른 미리 정의된 자료형에 연산자 쓰듯이 객체에도 사용할 수 있다.
	// 연산자 중첩 또한 함수 처럼 사용될 때 호출된다. 대신 호출은 연산자 모양 그대로 유지되기 때문에, 정의(기능)가 다르면 혼동할 수 있다.
	p1.Print();
	p2++;
	p2.Print();
	p3 = p1 + p2;
	p3.Print();
	p4 = p2 - p1;
	p4.Print();
	p4 = p1 * p2;
	p4.Print();
	cout << (p1 == p2) << endl;
	cout << (p1 == p5) << endl;
	cout << (p1 != p2) << endl;
	cout << (p1 != p5) << endl;
	i = p1; // 형 변환 함수 또한 연산자 중첩과 같이 대입하는 등 형 변환이 이루어질 때 호출된다.
	cout << i << endl;
	cout << p2 + 6 << endl;
	return 0;
}
// 실행 결과
//(3, 4)
//(4, 6)
//(7, 10)
//(1, 2)
//(12, 24)
//F
//T
//좌표값이 같다
//좌표값이 다르다
//12
//30

// 연산자 중첩을 클래스 밖에서 정의할 경우 operator 키워드 까지 함수 이름에 들어간다는 것을 기억하자.
// return *this는 객체 자신을 반환한다. 즉 Point형에서 return *this는 정의 안에서 계산한 값을 모두 
Point Point::operator ++() { ++x; ++y; return *this; }
Point Point::operator ++(int) { x++; y++; return *this; }
Point Point::operator +(Point ob) { Point temp; temp.x = x + ob.x; temp.y = y + ob.y; return temp; }
Point Point::operator -(Point ob) { Point temp; temp.x = x - ob.x; temp.y = y - ob.y; return temp; }
Point Point::operator *(Point ob) { Point temp; temp.x = x * ob.x; temp.y = y * ob.y; return temp; }
// Point Point::operator *(Point ob) { x=x*ob.x; y=y*ob.y; return temp; } // 연산 중 연산자의 주체인 p1도 바뀌기에 비추
char Point::operator ==(Point ob) { return (x == ob.x && y == ob.y) ? 'T' : 'F'; }
string Point::operator !=(Point ob) { return (x == ob.x && y == ob.y) ? "좌표값이 다르다" : "좌표값이 같다"; }

// 연산자 중첩의 제약
// 모든 연산자가 중첩될 수 있는 것은 아니다.
// .(멤버 호출) / .*(포인터 멤버 호출) / ::(네임스페이스) : 이 연산자들은 첫 번째 피 연산자로 객체를 갖는다는 미리 정의된 의미가 있어서
// ?: / sizeof -> 이 연산자들은 중첩이 필요 없다고 생각되므로

// 주의사항
// 0. 연산자 중첩은 멤버 함수와 같이 public 속성에 존재해 접근이 가능해야 main 함수와 같은 곳에서도 쓸 수 있다.
// 1. 연산자의 우선 순위를 변경할 수 있는 것은 아니다. ( 괄호 안이 우선 순위, +, -보다 *, / 먼저 처리 등 )
// 2. 단항을 2항, 3항과 같은 다항 연산자로 변경할 수 없다.
// 3. 임의의 새로운 연산자(**, <>)를 정의할 수 없다.
// 4. '+'와 '='과 정의되어도 '+='는 정의되지 않듯이, 각 연산자는 개별적으로 중첩이 필요하다.
// 5. 기본 자료형에 대해서는 중첩을 허용하지 않는다.
// 6. "=" 연산자를 제외하고, 연산자는 파생(자식) 클래스에 상속된다.
