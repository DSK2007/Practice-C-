#include <iostream>
using std::cout;
using std::endl;
// 함수 중첩 (Function Overloading)
// 출처 및 참고: 2021학년도 2학기 인덕대학교 한성현 교수님 C++프로그래밍 강좌 10주차
// 함수 중첩은 다형성(Polymorphism)의 종류에서 나온 문법으로, 다른 다형성 관련 문법은 연산자 중첩, 상속이 있다. C++에서는 컴파일 때 이 문법을 확인하고 사용한다.
// 함수 중첩은 C에서는 안되지만 C++와 같은 대부분의 객체 지향 언어에서 지원하는 기능으로 여러 개의 같은 이름의 변수를 다른 구현 방법으로 만드는 것을 의미한다.
// 컴파일 때 컴파일러가 함수의 이름이 같아도 매개 변수의 자료형, 혹은 갯수가 다르다면 이를 중첩했다는 것으로 치고, 호출 시 전달된 매개 변수의 입력 자료형, 갯수에 따라 자동으로 알맞는 매개 변수를 지닌 함수를 호출한다.
// 여러 개의 유사한 기능/목적을 가진 함수들을 하나의 함수명으로 사용하는 것으로 함수 중첩을 이루어 프로그램의 다형성을 구현할 수 있다. 다형성은 프로그램의 편리/간결성을 증진시킨다.

// 함수 중첩을 하는 1번째 경우 (예시): 매개 변수의 자료형이 다를 경우
int max(int i, int j) { return i > j ? i : j; }
// int max(int a, int b) { return a > b ? a : b; } // 함수 중첩이 안되는 1번째 예시: 완전히 매개 변수의 개수와 자료형이 같은 경우. 
// double max(int i, int j) { return i > j ? i : j; } // 함수 중첩이 안되는 2번째 예시: 매개 변수의 개수와 자료형이 같고, 반환형만 다른 경우 -> 매개 변수의 개수와 자료형이 같으면, 함수 중첩 시 컴파일러가 구분 불가
double max(double i, double j) { return i > j ? i : j; }
char max(char i, char j) { return i > j ? i : j; }
// template <class T> T max(T i, T j) { return i > j ? i : j; } // 매개 변수의 개수와 함수의 기능(정의)가 모두 유사하고 자료형만 다를 경우 함수의 Template를 맏드는 식으로도 나아갈 수 있다.

// 함수 중첩을 하는 2번째 경우 (예시): 매개 변수의 개수가 다를 경우
int add(int i, int j) { return i + j; }
int add(int i, int j, int k) { return i + j + k; }
int add(int i, int j, int k, int l) { return i + j + k + l; }

int main()
{
	// 함수 중첩은 함수의 매개 변수가 가지고 있는 자료형과 갯수에 따라 구분되어 이루어진다. 함수가 갖는 매개 변수의 자료형과 그 갯수가 똑같은 함수들은 중첩될 수 없다. 리턴헝만 다른 함수도 같은 원리로 중첩되지 않는다.
	// 예를 들자면 int add(int i, int j)와 double add(int k, int m)은 중첩될 수 없어 오류가 발생한다. 리턴형이 달라도, 가지고 있는 자료형과 그 갯수가 int 자료형 변수 2개로 동일하기 때문이다.
	// 기능(정의)가 아예 동일하고 매개 변수의 개수가 같은데, 자료형만 다른 경우, Template이라는 함수의 틀과 같은 문법을 사용해 더 짧은 코드로 정리할 수 있으나 이는 뒤에 더 자세히 다룰 것이다.
	cout << max(10, 30) << ", " << max(25.7, 33.8) << ", " << max('C', 'Z') << endl;
	// 함수 중첩의 장점은 이름이 같아 기능이 비슷한 것 끼리 묶어 놓았다는 것을 구분할 수 있어 프로그램의 코드가 보기에 더 간결해진다는 것이다.
	// C에서의 함수 중첩을 못하는 경우 생기는 단점과 반대로, 함수가 기능이 같은데도 처리하는 자료형이 따라 다른 이름을 부여하지 않아도 된다.
	cout << add(10, 30) << ", " << add(10, 30, 59) << ", " << add(10, 30, 59, 157) << endl;
	return 0;
}
// 실행 결과
//30, 33.8, Z
//40, 99, 256
